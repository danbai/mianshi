<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>浏览器内部工作原理</title>
    <link rel="stylesheet" href="">
</head>
<body>
    <p>1111</p>
    <script src=""></script>
    <script>
    /*
    1.为什么要了解浏览器加载,解析,渲染
        1.了解浏览器如何进行加载,可以在引用外部样式文件css,外部js时,将他们放到合适的位置,
        使浏览器以最快的速度将文件加载完毕.
        2.了解浏览器如何进行解析,可以在构建DOM结构,组织css选择器时,选择最优的写法,提高浏览器的解析速率.
        3.了解浏览器如何进行渲染,明白渲染的过程,在设置元素属性,编写js文件时,可以减少'reflow','repaint'的消耗.
    2.浏览器的主要功能
        1.浏览器的主要功能是将用户选择的web资源呈现出来.
        用户用URI(统一资源标识符)来指定所请求资源的位置,通过DNS查询,将网址转换为IP地址.
        浏览器缓存DNS,host文件,路由器缓存,外部DNS服务器
        浏览器给web服务器发送一个HTTP请求.
        服务器'处理'请求,服务器接收到获取请求,然后处理并返回一个响应.
        服务器发回一个html响应,浏览器开始显示html.
        浏览器发送请求,以获取嵌入在HTML中的对象,这些文件包括css/js/图片等资源,
        这些资源的地址都要经历一个和html读取类似的过程,DNS查找,http请求.
    3.浏览器的渲染
        1.渲染引擎在取得内容之后的基本流程:解析html以构建dom树->构建render树->布局render树->绘制render树
        浏览器会解析三个东西:
            1.html/svg/xhtml,解析这三种文件会产生一个DOM TREE.
            2.css,解析css会产生css规则树.
            3.js脚本,主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.
        2.当浏览器获得一个html文件时,会'自上而下'加载,并在加载过程中进行解析渲染.
        解析:
            1.浏览器会将html解析成一个DOM树,DOM树的构建过程是一个深度遍历过程:当前节点的所有子节点都构建好后
            才会去构建当前节点的下一个兄弟节点.
            2.将css解析成CSS Rule Tree.
            3.根据DOM树和CSSOM来构造Rendering Tree.注意: Rendering Tree渲染树并不等同于DOM树,因为一些像
            Header或display:none的东西就没必要放在渲染树中了.
            4.有了render tree,浏览器已经能知道网页中有哪些节点,各个节点的css定义以及他们的从属关系.
            下一步操作称之为Layout,顾名思义就是计算出每个节点在屏幕中的位置.
            5.再下一步就是绘制,即遍历render树,并使用UI后端层绘制每个节点.
        上述这个过程是逐步完成的,为了更好的用户体验,渲染引擎将会尽可能早的将内容呈现到屏幕上,并不会等到
        所有的html都解析完成之后再去构建和布局render树.
        它是解析完一部分内容就显示一部分内容,同时,可能还在通过网络下载其余内容.
        3.几个概念
            1.reflow(回流):浏览器要花时间去渲染,当它发现了某个部分发生了变化影响了布局,那就需要倒回去重新渲染.
            2.repaint(重绘):如果只是改变了某个元素的背景颜色,文字颜色等,不影响元素周围或内部布局的属性,
            将只会引起浏览器的repaint,重画某一部分.
            reflow要比repaint更花费时间,也就更影响性能,所在在写代码的时候,需尽量避免更多的reflow.
            reflow的原因:
                1.页面初始化的时候
                2.操作DOM时
                3.某些元素的尺寸变了
                4.如果css的属性发生变化了
            减少reflow/repaint:
                1.不要一条条的修改DOM的样式,与其这样,还不如预先定义好css的class,然后修改DOM的className.
                2.不要把DOM节点的属性值放在一个循环里当成循环里的变量.
                3.为动画的html元素使用fixed或absolute的position,那么修该他们的css是不会reflow的.
                4.千万不要使用table布局,因为可能很小的一个改动会造成整个table的重新布局.
        4.html页面加载和解析流程
            1.用户输入网址(DNS,IP,服务器,http请求,假设是个html页面,并且是第一次访问),浏览器向服务器发出请求,服务器返回html文件.
            2.浏览器开始载入html文件,发现<head>标签内有一个<link>标签引用外部css文件.
            3.浏览器又发出css文件的请求,服务器返回这个css文件.
            4.浏览器继续载入<body>部分的代码,并且css文件已经拿到手了,可以开始渲染页面了.
            5.浏览器在代码中发现一个<img>标签引用了一张图片,向服务器发出请求,此时浏览器不会等到图片下载完,
            而是继续渲染后面的代码.
            6.服务器返回图片文件,由于图片占用了一定面积,影响了后面段落的排布,因此浏览器需要回过头来重新渲染这部分代码.
            7.浏览器发现了一个包含一行js代码的<script>标签,赶快运行它.
            8.js脚本执行了这条语句,它命令浏览器隐藏掉代码中的某个div(style="display:none;"),
            突然少了这么一个元素,浏览器不得不重新渲染这部分代码.
            9.终于等到了</html>的到来,浏览器泪流满面.
            10.等等,还没完,用户点了一下界面中的'换肤'按钮,js让浏览器换了一下<link>标签的css路径
            11.浏览器召集了在座的各位<div><span><ul><li>们,'大伙儿收拾收拾行李,咱得重新来过',
            浏览器向服务器请求了新的css文件,重新渲染页面.
        5.编写css时应该注意
            css选择符是从右到左匹配,所以#nav li我们以为这是一条简单的规则,秒秒钟就能匹配到想要的元素,
            但是会去找所有的li,然后再去确定它的父元素是不是#nav.
            1.dom深度尽量浅
            2.减少inline javascript css的数量
            3.使用现代合法的css属性
            4.不要为id选择器指定类名或是标签,因为id可以唯一确定一个元素.
            5.避免后代选择符,尽量使用子选择符,子元素匹配符的概率要大于后代元素匹配符.#demo p {},#demo > p {}
            6.避免使用通配符   .mod * {},根据匹配顺序,将首先匹配通配符,然后匹配.mod,
            就是要对dom树上的所有节点进行遍历它的父级元素,然后匹配.mod,这样的性能消耗可想而知.
        6.关于script的位置
            1.js代码在加载完后,是立即执行的.
            2.js的下载和执行会阻塞DOM树的构建(包括页面的渲染,其他资源的下载).
            因为浏览器需要一个稳定的DOM树结构,而js中有代码可能改变了DOM树结构,阻塞其他的下载和呈现.
        7.减少js对性能的影响的方法
            1.将所有的script标签放到页面底部,也就是body闭合标签之前,这能确保在脚本执行前页面已经完成了DOM树渲染.
            2.尽可能合并脚本,页面中的script标签越少,加载也就越快,响应也越迅速,无论是外链脚本还是内嵌脚本都是.
            3.采用无阻塞下载js脚本的方法:
                1.使用script标签的defer属性
                2.使用动态创建的script元素来下载并执行代码
        8.script defer async
        1.没有defer和async,浏览器会立即加载并执行指定的脚本,立即指的是在渲染该script标签之下的文档元素之前,
        也就是说不等待后续载入的文档元素,读到就加载并执行.
        2.有async,加载和渲染后续文档元素的过程讲个script.js的加载与执行并行进行(异步).
        3.有defer,加载后续文档元素的过程将和script.js的加载并行执行(异步),但是script.js的执行要在所有元素解析完成之后
        ,DOMContentLoaded事件触发之前完成.
        4.defer和async在网络读取(加载)这块儿是一样的,都是异步的.
        它俩的差别在于脚本下载完之后何时执行,显然defer是最接近我们对于脚本加载和执行的要求的.
        5.关于defer,是按照加载顺序执行脚本的.async则是乱序执行.
    */
    </script>
</body>
</html>