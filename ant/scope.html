<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>作为命名空间的函数</title>
</head>
<body>
    <script>
        /*
        1.在函数中声明的变量在整个函数体内都是可见的(包括在嵌套函数中),在函数外部是不可见的.
        不在任何函数内声明的变量是全局变量,在整个js程序中都是可见的.
        我们常常简单的定义一个函数用作临时的命名空间,在这个命名空间内定义的变量都不会污染到全局命名空间.
        2.js是基于词法作用域的语言:通过阅读包含变量定义在内的数行源码就能知道变量的作用域.
        全局变量在程序中始终都是有定义的.局部变量在声明它的函数体内以及其所嵌套的函数体内始终是有定义的.
        每一段js代码都有一个与之相关的作用域链(scope chain),这个作用域链是一个对象列表或链表,
        这组对象定义了这段代码'作用域'中的变量.
        当js需要查找变量x的值的时候,他会从链中的第一个对象开始查找,如果这个对象有一个名为x的属性,
        则会直接使用这个属性的值,如果第一个对象中不存在名为x的属性,则会继续查找下一个对象,以此类推.
        如果作用域链上没有任何一个对象含有属性x,那么就认为这段代码的作用域链上不存在x,
        并最终抛出一个引用错误(ReferenceError)异常.
        3.在js的最顶层代码中,作用域链由一个全局对象组成,在不包含嵌套的函数体内,作用域链上有两个对象,
        第一个是定义函数参数和局部变量的对象,第二个是全局对象.
        在一个嵌套的函数体内,作用域链上至少有三个对象.
        4.当定义一个函数时,它实际上保存一个作用域链.
        当调用这个函数时,他创建一个新的对象来存储它的局部变量,并将这个对象添加至保存的那个作用域链上,同时创建
        一个新的更长的表示函数调用作用域的链.
        对于嵌套函数来讲,事情变得更加有趣,每次调用外部函数的时候,内部函数又会重新定义一次.
        因为每次调用外部函数的时候,作用域链都是不同的.
        */
        var extend = (function() {
            var a = 1,
                b = 2;

            return function(x, y) {
                return x + y + a + b;
            }
        }());

        // console.log(a);
        // console.log(b);
        console.log(extend(3, 4));

        function test(o) {
            var i = 0;

            if (typeof o === 'object') {
                var j = 0;
                for (var k = 0; k < 10; k++) {
                    console.log(k);
                }
                console.log(k);
            }
            console.log(j);
        }

        test({x: 1});   // 0-9 10 0
        test(); // undefined
    </script>
</body>
</html>